/**
 * Security Utilities - The Sovereign Guard
 *
 * Cryptographic and security-related utilities.
 * Every function here is designed to be resistant to timing attacks and side-channels.
 */

import { AppError } from './errors';

// ============================================================================
// Constant-Time Comparison
// ============================================================================

/**
 * Compare two strings in constant time to prevent timing attacks.
 *
 * Timing attacks work by measuring how long a comparison takes.
 * If we use `===`, the comparison stops at the first mismatch,
 * leaking information about which characters are correct.
 *
 * This function always compares ALL characters, taking the same
 * time regardless of where mismatches occur.
 */
export function constantTimeEquals(a: string, b: string): boolean {
  // If lengths differ, we still need to do work to avoid timing leak
  // We use the longer string to ensure consistent timing
  const aLen = a.length;
  const bLen = b.length;

  // XOR of lengths will be 0 if equal
  let result = aLen ^ bLen;

  // Compare all characters of the longer string
  const maxLen = Math.max(aLen, bLen);
  for (let i = 0; i < maxLen; i++) {
    // Use modulo to safely access characters (wraps around for shorter string)
    const aChar = a.charCodeAt(i % aLen) || 0;
    const bChar = b.charCodeAt(i % bLen) || 0;
    result |= aChar ^ bChar;
  }

  return result === 0;
}

// ============================================================================
// Admin API Key Verification
// ============================================================================

/**
 * Verify admin API key from X-API-Key header.
 * Uses constant-time comparison to prevent timing attacks.
 *
 * @throws AppError if key is missing, invalid, or API is not configured
 */
export function verifyAdminApiKey(request: Request, adminKey: string | undefined): void {
  if (!adminKey) {
    throw new AppError(
      'INTERNAL_ERROR',
      'Admin API is not configured. Set ADMIN_API_KEY secret.',
      503
    );
  }

  const providedKey = request.headers.get('X-API-Key');

  if (!providedKey) {
    throw new AppError(
      'UNAUTHORIZED',
      'Missing X-API-Key header',
      401
    );
  }

  if (!constantTimeEquals(providedKey, adminKey)) {
    throw new AppError('UNAUTHORIZED', 'Invalid API key', 403);
  }
}

// ============================================================================
// HMAC Utilities for Machine Signature Verification
// ============================================================================

/**
 * Compute HMAC-SHA256 signature of a message.
 *
 * Used to verify that machine_id was generated by a legitimate CLI
 * and hasn't been tampered with.
 */
export async function computeHmacSignature(
  message: string,
  secretKey: string
): Promise<string> {
  const encoder = new TextEncoder();

  // Import the secret key
  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secretKey),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  );

  // Sign the message
  const signature = await crypto.subtle.sign(
    'HMAC',
    key,
    encoder.encode(message)
  );

  // Convert to hex string
  return Array.from(new Uint8Array(signature))
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Verify an HMAC signature against a message.
 * Uses constant-time comparison to prevent timing attacks.
 */
export async function verifyHmacSignature(
  message: string,
  signature: string,
  secretKey: string
): Promise<boolean> {
  const expectedSignature = await computeHmacSignature(message, secretKey);
  return constantTimeEquals(signature, expectedSignature);
}

// ============================================================================
// Request Validation Helpers
// ============================================================================

/**
 * Maximum allowed Content-Length for JSON requests (100KB).
 * This prevents DoS attacks via large payloads.
 */
export const MAX_CONTENT_LENGTH = 100 * 1024; // 100KB

/**
 * Validate request Content-Length to prevent DoS via large payloads.
 *
 * @throws AppError if Content-Length exceeds maximum
 */
export function validateContentLength(request: Request, maxBytes: number = MAX_CONTENT_LENGTH): void {
  const contentLength = request.headers.get('Content-Length');

  if (contentLength) {
    const length = parseInt(contentLength, 10);
    if (isNaN(length) || length > maxBytes) {
      throw new AppError(
        'INVALID_REQUEST',
        `Request body too large. Maximum: ${Math.round(maxBytes / 1024)}KB`,
        413
      );
    }
  }
}

/**
 * Validate request timestamp for replay attack protection.
 * Rejects requests that are too old or too far in the future.
 *
 * @param timestamp - Request timestamp in milliseconds since epoch
 * @param maxAgeMs - Maximum age of request in milliseconds (default: 5 minutes)
 * @param maxFutureMs - Maximum amount request can be in the future (default: 1 minute)
 */
export function validateRequestTimestamp(
  timestamp: number | undefined,
  maxAgeMs: number = 5 * 60 * 1000,
  maxFutureMs: number = 60 * 1000
): boolean {
  if (!timestamp) {
    // Timestamp is optional for backward compatibility
    return true;
  }

  const now = Date.now();
  const minTime = now - maxAgeMs;
  const maxTime = now + maxFutureMs;

  return timestamp >= minTime && timestamp <= maxTime;
}

// ============================================================================
// CLI Version Checking
// ============================================================================

/** Minimum supported CLI version */
const MIN_SUPPORTED_VERSION = '0.1.0';

/** Versions that should show deprecation warning */
const DEPRECATED_VERSIONS = ['0.9.0', '0.9.1', '0.9.2', '0.1.0', '0.1.1', '0.1.2'];

/** Version warning to include in response */
export interface VersionWarning {
  message: string;
  upgrade_command: string;
  severity: 'warning' | 'deprecated' | 'unsupported';
}

/**
 * Parse semver version string into comparable number.
 * Example: "1.2.3" -> 10203
 */
function parseVersion(version: string): number | null {
  const match = version.match(/^(\d+)\.(\d+)\.(\d+)/);
  if (!match) return null;

  const [, major, minor, patch] = match;
  return parseInt(major) * 10000 + parseInt(minor) * 100 + parseInt(patch);
}

/**
 * Check CLI version and return warning if outdated.
 * Does NOT reject requests - only warns for backward compatibility.
 */
export function checkVersionHeader(version: string | null): VersionWarning | null {
  if (!version) {
    // No version header - old CLI, warn but allow
    return {
      message: 'No CLI version header detected. Consider upgrading for best experience.',
      upgrade_command: 'pip install --upgrade replimap',
      severity: 'warning',
    };
  }

  const versionNum = parseVersion(version);
  const minVersionNum = parseVersion(MIN_SUPPORTED_VERSION);

  if (versionNum === null || minVersionNum === null) {
    return null; // Can't parse, allow
  }

  // Check if deprecated version
  if (DEPRECATED_VERSIONS.includes(version)) {
    return {
      message: `CLI version ${version} is deprecated. Please upgrade for security fixes and new features.`,
      upgrade_command: 'pip install --upgrade replimap',
      severity: 'deprecated',
    };
  }

  // Check if below minimum
  if (versionNum < minVersionNum) {
    return {
      message: `CLI version ${version} is outdated. Minimum supported: ${MIN_SUPPORTED_VERSION}`,
      upgrade_command: 'pip install --upgrade replimap',
      severity: 'unsupported',
    };
  }

  return null;
}

// ============================================================================
// Abuse Detection
// ============================================================================

/**
 * Maximum number of unique devices before flagging as potential abuse.
 * This is a soft limit - we warn but don't hard-block until extreme cases.
 */
export const MAX_DEVICES_BEFORE_WARNING = 25;
export const MAX_DEVICES_BEFORE_ABUSE = 50;

/**
 * Check device count for potential abuse.
 * Returns warning message if suspicious, null if OK.
 */
export function checkDeviceAbuse(
  deviceCount: number
): { isAbuse: boolean; warning: string | null } {
  if (deviceCount >= MAX_DEVICES_BEFORE_ABUSE) {
    return {
      isAbuse: true,
      warning: `License used on ${deviceCount} devices. This appears to be shared. Contact support.`,
    };
  }

  if (deviceCount >= MAX_DEVICES_BEFORE_WARNING) {
    return {
      isAbuse: false,
      warning: `License used on ${deviceCount} devices. Consider upgrading to a team plan.`,
    };
  }

  return { isAbuse: false, warning: null };
}

// ============================================================================
// Error Sanitization (Hide Stack Traces)
// ============================================================================

/**
 * Sanitize error for external response.
 * Never expose stack traces or internal details to clients.
 */
export function sanitizeError(error: unknown, requestId?: string): {
  error: string;
  message: string;
  request_id?: string;
} {
  // Generate request ID if not provided
  const id = requestId || `REQ-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`.toUpperCase();

  // Log full error internally
  console.error(`[ERROR ${id}]`, error);

  // Return sanitized response
  return {
    error: 'INTERNAL_ERROR',
    message: 'An unexpected error occurred. Please try again.',
    request_id: id,
  };
}

/**
 * Log error with context for debugging, without exposing details.
 */
export function logError(context: string, error: unknown): void {
  const errorInfo = error instanceof Error
    ? { message: error.message, stack: error.stack, name: error.name }
    : { value: String(error) };

  console.error(`[ERROR] ${context}:`, JSON.stringify(errorInfo));
}
