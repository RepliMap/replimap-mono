/**
 * Security Utilities - The Sovereign Guard
 *
 * Cryptographic and security-related utilities.
 * Every function here is designed to be resistant to timing attacks and side-channels.
 */

import { AppError } from './errors';

// ============================================================================
// Constant-Time Comparison
// ============================================================================

/**
 * Compare two strings in constant time to prevent timing attacks.
 *
 * Timing attacks work by measuring how long a comparison takes.
 * If we use `===`, the comparison stops at the first mismatch,
 * leaking information about which characters are correct.
 *
 * This function always compares ALL characters, taking the same
 * time regardless of where mismatches occur.
 */
export function constantTimeEquals(a: string, b: string): boolean {
  // If lengths differ, we still need to do work to avoid timing leak
  // We use the longer string to ensure consistent timing
  const aLen = a.length;
  const bLen = b.length;

  // XOR of lengths will be 0 if equal
  let result = aLen ^ bLen;

  // Compare all characters of the longer string
  const maxLen = Math.max(aLen, bLen);
  for (let i = 0; i < maxLen; i++) {
    // Use modulo to safely access characters (wraps around for shorter string)
    const aChar = a.charCodeAt(i % aLen) || 0;
    const bChar = b.charCodeAt(i % bLen) || 0;
    result |= aChar ^ bChar;
  }

  return result === 0;
}

// ============================================================================
// Admin API Key Verification
// ============================================================================

/**
 * Verify admin API key from X-API-Key header.
 * Uses constant-time comparison to prevent timing attacks.
 *
 * @throws AppError if key is missing, invalid, or API is not configured
 */
export function verifyAdminApiKey(request: Request, adminKey: string | undefined): void {
  if (!adminKey) {
    throw new AppError(
      'INTERNAL_ERROR',
      'Admin API is not configured. Set ADMIN_API_KEY secret.',
      503
    );
  }

  const providedKey = request.headers.get('X-API-Key');

  if (!providedKey) {
    throw new AppError(
      'UNAUTHORIZED',
      'Missing X-API-Key header',
      401
    );
  }

  if (!constantTimeEquals(providedKey, adminKey)) {
    throw new AppError('UNAUTHORIZED', 'Invalid API key', 403);
  }
}

// ============================================================================
// HMAC Utilities for Machine Signature Verification
// ============================================================================

/**
 * Compute HMAC-SHA256 signature of a message.
 *
 * Used to verify that machine_id was generated by a legitimate CLI
 * and hasn't been tampered with.
 */
export async function computeHmacSignature(
  message: string,
  secretKey: string
): Promise<string> {
  const encoder = new TextEncoder();

  // Import the secret key
  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secretKey),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  );

  // Sign the message
  const signature = await crypto.subtle.sign(
    'HMAC',
    key,
    encoder.encode(message)
  );

  // Convert to hex string
  return Array.from(new Uint8Array(signature))
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Verify an HMAC signature against a message.
 * Uses constant-time comparison to prevent timing attacks.
 */
export async function verifyHmacSignature(
  message: string,
  signature: string,
  secretKey: string
): Promise<boolean> {
  const expectedSignature = await computeHmacSignature(message, secretKey);
  return constantTimeEquals(signature, expectedSignature);
}

// ============================================================================
// Request Validation Helpers
// ============================================================================

/**
 * Maximum allowed Content-Length for JSON requests (100KB).
 * This prevents DoS attacks via large payloads.
 */
export const MAX_CONTENT_LENGTH = 100 * 1024; // 100KB

/**
 * Validate request Content-Length to prevent DoS via large payloads.
 *
 * @throws AppError if Content-Length exceeds maximum
 */
export function validateContentLength(request: Request, maxBytes: number = MAX_CONTENT_LENGTH): void {
  const contentLength = request.headers.get('Content-Length');

  if (contentLength) {
    const length = parseInt(contentLength, 10);
    if (isNaN(length) || length > maxBytes) {
      throw new AppError(
        'INVALID_REQUEST',
        `Request body too large. Maximum: ${Math.round(maxBytes / 1024)}KB`,
        413
      );
    }
  }
}

/**
 * Validate request timestamp for replay attack protection.
 * Rejects requests that are too old or too far in the future.
 *
 * @param timestamp - Request timestamp in milliseconds since epoch
 * @param maxAgeMs - Maximum age of request in milliseconds (default: 5 minutes)
 * @param maxFutureMs - Maximum amount request can be in the future (default: 1 minute)
 */
export function validateRequestTimestamp(
  timestamp: number | undefined,
  maxAgeMs: number = 5 * 60 * 1000,
  maxFutureMs: number = 60 * 1000
): boolean {
  if (!timestamp) {
    // Timestamp is optional for backward compatibility
    return true;
  }

  const now = Date.now();
  const minTime = now - maxAgeMs;
  const maxTime = now + maxFutureMs;

  return timestamp >= minTime && timestamp <= maxTime;
}
