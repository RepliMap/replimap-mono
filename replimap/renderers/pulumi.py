"""
Pulumi Renderer for RepliMap.

Converts the resource graph to Pulumi Python code.
This renderer requires Pro plan or higher.
"""

from __future__ import annotations

import logging
from pathlib import Path
from typing import TYPE_CHECKING

from replimap.core.models import ResourceType
from replimap.licensing import Feature
from replimap.licensing.gates import feature_gate
from replimap.renderers.base import BaseRenderer

if TYPE_CHECKING:
    from replimap.core import GraphEngine, ResourceNode

logger = logging.getLogger(__name__)


class PulumiRenderer(BaseRenderer):
    """
    Renders the resource graph to Pulumi Python code.

    Output structure:
    - __main__.py: Main Pulumi program
    - network.py: VPCs, Subnets, Security Groups
    - compute.py: EC2 Instances
    - database.py: RDS Instances
    - storage.py: S3 Buckets
    - Pulumi.yaml: Project configuration
    - requirements.txt: Python dependencies

    Requires: Pro plan or higher
    """

    # Mapping of resource types to output files
    FILE_MAPPING = {
        ResourceType.VPC: "network.py",
        ResourceType.SUBNET: "network.py",
        ResourceType.SECURITY_GROUP: "network.py",
        ResourceType.EC2_INSTANCE: "compute.py",
        ResourceType.S3_BUCKET: "storage.py",
        ResourceType.RDS_INSTANCE: "database.py",
        ResourceType.DB_SUBNET_GROUP: "database.py",
    }

    @property
    def name(self) -> str:
        return "Pulumi"

    @property
    def format_name(self) -> str:
        return "pulumi"

    @feature_gate(Feature.PULUMI_OUTPUT)
    def render(self, graph: GraphEngine, output_dir: Path) -> dict[str, Path]:
        """
        Render the graph to Pulumi Python files.

        Args:
            graph: The GraphEngine containing resources
            output_dir: Directory to write Python files

        Returns:
            Dictionary mapping filenames to their paths
        """
        output_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f"Rendering Pulumi to {output_dir}")

        # Group resources by output file
        file_resources: dict[str, list[ResourceNode]] = {}

        for resource in graph.topological_sort():
            output_file = self.FILE_MAPPING.get(resource.resource_type)
            if output_file:
                if output_file not in file_resources:
                    file_resources[output_file] = []
                file_resources[output_file].append(resource)

        # Generate module files
        written_files: dict[str, Path] = {}
        module_imports = []

        for filename, resources in file_resources.items():
            code = self._generate_module(filename, resources, graph)
            file_path = output_dir / filename

            with open(file_path, "w") as f:
                f.write(code)

            written_files[filename] = file_path
            module_imports.append(filename.replace(".py", ""))
            logger.info(f"Wrote {filename} ({len(resources)} resources)")

        # Generate main entry point
        self._generate_main(output_dir, module_imports, written_files)

        # Generate project configuration
        self._generate_pulumi_yaml(output_dir, written_files)

        # Generate requirements.txt
        self._generate_requirements(output_dir, written_files)

        return written_files

    def preview(self, graph: GraphEngine) -> dict[str, list[str]]:
        """Preview what would be generated without writing files."""
        preview: dict[str, list[str]] = {}

        for resource in graph.iter_resources():
            output_file = self.FILE_MAPPING.get(resource.resource_type)
            if output_file:
                if output_file not in preview:
                    preview[output_file] = []
                preview[output_file].append(resource.id)

        return preview

    def _generate_module(
        self, filename: str, resources: list[ResourceNode], graph: GraphEngine
    ) -> str:
        """Generate a Pulumi Python module for a set of resources."""
        lines = [
            '"""',
            f"Generated by RepliMap - {filename}",
            '"""',
            "",
            "import pulumi",
            "import pulumi_aws as aws",
            "",
            "",
        ]

        # Generate resource definitions
        for resource in resources:
            resource_code = self._convert_resource(resource, graph)
            if resource_code:
                lines.append(resource_code)
                lines.append("")

        # Generate exports
        lines.append("# Exports")
        for resource in resources:
            var_name = self._to_variable_name(resource.terraform_name)
            if resource.resource_type == ResourceType.VPC:
                lines.append(f"pulumi.export('{var_name}_id', {var_name}.id)")
            elif resource.resource_type == ResourceType.SUBNET:
                lines.append(f"pulumi.export('{var_name}_id', {var_name}.id)")

        return "\n".join(lines)

    def _convert_resource(
        self, resource: ResourceNode, graph: GraphEngine
    ) -> str | None:
        """Convert a ResourceNode to Pulumi Python code."""
        converters = {
            ResourceType.VPC: self._convert_vpc,
            ResourceType.SUBNET: self._convert_subnet,
            ResourceType.SECURITY_GROUP: self._convert_security_group,
            ResourceType.EC2_INSTANCE: self._convert_ec2,
            ResourceType.S3_BUCKET: self._convert_s3,
            ResourceType.RDS_INSTANCE: self._convert_rds,
        }

        converter = converters.get(resource.resource_type)
        if converter:
            return converter(resource, graph)
        return None

    def _convert_vpc(self, resource: ResourceNode, graph: GraphEngine) -> str:
        """Convert VPC to Pulumi."""
        config = resource.config
        var_name = self._to_variable_name(resource.terraform_name)

        return f'''{var_name} = aws.ec2.Vpc(
    "{resource.terraform_name}",
    cidr_block="{config.get("cidr_block", "10.0.0.0/16")}",
    enable_dns_hostnames={config.get("enable_dns_hostnames", True)},
    enable_dns_support={config.get("enable_dns_support", True)},
    tags={{
        "Name": "{resource.original_name}",
        "ManagedBy": "RepliMap",
    }},
)'''

    def _convert_subnet(self, resource: ResourceNode, graph: GraphEngine) -> str:
        """Convert Subnet to Pulumi."""
        config = resource.config
        var_name = self._to_variable_name(resource.terraform_name)

        # Find VPC reference
        vpc_ref = "vpc.id"  # Default
        for dep in resource.dependencies:
            dep_resource = graph.get_resource(dep.target_id)
            if dep_resource and dep_resource.resource_type == ResourceType.VPC:
                vpc_var = self._to_variable_name(dep_resource.terraform_name)
                vpc_ref = f"{vpc_var}.id"
                break

        az = config.get("availability_zone", "us-east-1a")
        cidr = config.get("cidr_block", "10.0.1.0/24")
        map_public = config.get("map_public_ip_on_launch", False)

        return f'''{var_name} = aws.ec2.Subnet(
    "{resource.terraform_name}",
    vpc_id={vpc_ref},
    cidr_block="{cidr}",
    availability_zone="{az}",
    map_public_ip_on_launch={map_public},
    tags={{
        "Name": "{resource.original_name}",
        "ManagedBy": "RepliMap",
    }},
)'''

    def _convert_security_group(
        self, resource: ResourceNode, graph: GraphEngine
    ) -> str:
        """Convert Security Group to Pulumi."""
        config = resource.config
        var_name = self._to_variable_name(resource.terraform_name)

        # Find VPC reference
        vpc_ref = "vpc.id"
        for dep in resource.dependencies:
            dep_resource = graph.get_resource(dep.target_id)
            if dep_resource and dep_resource.resource_type == ResourceType.VPC:
                vpc_var = self._to_variable_name(dep_resource.terraform_name)
                vpc_ref = f"{vpc_var}.id"
                break

        # Convert ingress rules
        ingress_rules = []
        for rule in config.get("ingress", []):
            rule_dict = {
                "protocol": rule.get("protocol", "-1"),
                "from_port": rule.get("from_port", 0),
                "to_port": rule.get("to_port", 0),
                "cidr_blocks": rule.get("cidr_blocks", ["0.0.0.0/0"]),
            }
            ingress_rules.append(rule_dict)

        ingress_str = self._format_ingress_rules(ingress_rules)
        description = config.get(
            "description", f"Security group {resource.original_name}"
        )

        return f'''{var_name} = aws.ec2.SecurityGroup(
    "{resource.terraform_name}",
    vpc_id={vpc_ref},
    description="{description}",
    ingress=[{ingress_str}],
    egress=[
        aws.ec2.SecurityGroupEgressArgs(
            protocol="-1",
            from_port=0,
            to_port=0,
            cidr_blocks=["0.0.0.0/0"],
        ),
    ],
    tags={{
        "Name": "{resource.original_name}",
        "ManagedBy": "RepliMap",
    }},
)'''

    def _convert_ec2(self, resource: ResourceNode, graph: GraphEngine) -> str:
        """Convert EC2 Instance to Pulumi."""
        config = resource.config
        var_name = self._to_variable_name(resource.terraform_name)

        # Find subnet and security group references
        subnet_ref = "subnet.id"
        sg_refs = []
        for dep in resource.dependencies:
            dep_resource = graph.get_resource(dep.target_id)
            if dep_resource:
                dep_var = self._to_variable_name(dep_resource.terraform_name)
                if dep_resource.resource_type == ResourceType.SUBNET:
                    subnet_ref = f"{dep_var}.id"
                elif dep_resource.resource_type == ResourceType.SECURITY_GROUP:
                    sg_refs.append(f"{dep_var}.id")

        sg_list = ", ".join(sg_refs) if sg_refs else "[]"
        instance_type = config.get("instance_type", "t3.micro")
        ami = config.get("ami", "ami-0123456789abcdef0")

        return f'''{var_name} = aws.ec2.Instance(
    "{resource.terraform_name}",
    instance_type="{instance_type}",
    ami="{ami}",
    subnet_id={subnet_ref},
    vpc_security_group_ids=[{sg_list}],
    tags={{
        "Name": "{resource.original_name}",
        "ManagedBy": "RepliMap",
    }},
)'''

    def _convert_s3(self, resource: ResourceNode, graph: GraphEngine) -> str:
        """Convert S3 Bucket to Pulumi."""
        config = resource.config
        var_name = self._to_variable_name(resource.terraform_name)

        bucket_name = config.get("bucket_name", resource.terraform_name)

        return f'''{var_name} = aws.s3.Bucket(
    "{resource.terraform_name}",
    bucket="{bucket_name}",
    versioning=aws.s3.BucketVersioningArgs(
        enabled={config.get("versioning", False)},
    ),
    tags={{
        "Name": "{resource.original_name}",
        "ManagedBy": "RepliMap",
    }},
)'''

    def _convert_rds(self, resource: ResourceNode, graph: GraphEngine) -> str:
        """Convert RDS Instance to Pulumi."""
        config = resource.config
        var_name = self._to_variable_name(resource.terraform_name)

        # Find security group references
        sg_refs = []
        for dep in resource.dependencies:
            dep_resource = graph.get_resource(dep.target_id)
            if (
                dep_resource
                and dep_resource.resource_type == ResourceType.SECURITY_GROUP
            ):
                dep_var = self._to_variable_name(dep_resource.terraform_name)
                sg_refs.append(f"{dep_var}.id")

        sg_list = ", ".join(sg_refs) if sg_refs else "[]"
        identifier = config.get("identifier", resource.terraform_name)
        instance_class = config.get("instance_class", "db.t3.micro")
        engine = config.get("engine", "mysql")
        allocated_storage = config.get("allocated_storage", 20)

        return f'''{var_name} = aws.rds.Instance(
    "{resource.terraform_name}",
    identifier="{identifier}",
    instance_class="{instance_class}",
    engine="{engine}",
    allocated_storage={allocated_storage},
    username="admin",
    password="CHANGE_ME",  # Use pulumi.Config or secrets manager
    vpc_security_group_ids=[{sg_list}],
    skip_final_snapshot=True,
    tags={{
        "Name": "{resource.original_name}",
        "ManagedBy": "RepliMap",
    }},
)'''

    def _format_ingress_rules(self, rules: list[dict]) -> str:
        """Format ingress rules as Pulumi args."""
        if not rules:
            return ""

        rule_strs = []
        for rule in rules:
            cidr_blocks = rule.get("cidr_blocks", ["0.0.0.0/0"])
            cidr_str = ", ".join(f'"{c}"' for c in cidr_blocks)
            rule_strs.append(f'''
        aws.ec2.SecurityGroupIngressArgs(
            protocol="{rule.get("protocol", "-1")}",
            from_port={rule.get("from_port", 0)},
            to_port={rule.get("to_port", 0)},
            cidr_blocks=[{cidr_str}],
        )''')

        return ",".join(rule_strs)

    def _generate_main(
        self, output_dir: Path, modules: list[str], written_files: dict[str, Path]
    ) -> None:
        """Generate the main Pulumi entry point."""
        imports = "\n".join(f"from . import {m}" for m in modules)

        main_code = f'''"""
RepliMap - Pulumi Infrastructure
Generated staging environment from AWS production scan.
"""

import pulumi

# Import infrastructure modules
{imports}

# Stack configuration
config = pulumi.Config()
environment = config.get("environment") or "staging"

pulumi.export("environment", environment)
'''

        main_path = output_dir / "__main__.py"
        with open(main_path, "w") as f:
            f.write(main_code)
        written_files["__main__.py"] = main_path
        logger.info("Wrote __main__.py")

    def _generate_pulumi_yaml(
        self, output_dir: Path, written_files: dict[str, Path]
    ) -> None:
        """Generate Pulumi.yaml project configuration."""
        config = """name: replimap-staging
runtime:
  name: python
  options:
    virtualenv: venv
description: Staging environment generated by RepliMap
"""

        config_path = output_dir / "Pulumi.yaml"
        with open(config_path, "w") as f:
            f.write(config)
        written_files["Pulumi.yaml"] = config_path
        logger.info("Wrote Pulumi.yaml")

    def _generate_requirements(
        self, output_dir: Path, written_files: dict[str, Path]
    ) -> None:
        """Generate requirements.txt for Pulumi dependencies."""
        requirements = """pulumi>=3.0.0
pulumi-aws>=6.0.0
"""

        req_path = output_dir / "requirements.txt"
        with open(req_path, "w") as f:
            f.write(requirements)
        written_files["requirements.txt"] = req_path
        logger.info("Wrote requirements.txt")

    @staticmethod
    def _to_variable_name(name: str) -> str:
        """Convert a name to a valid Python variable name."""
        result = ""
        for char in name:
            if char.isalnum() or char == "_":
                result += char
            else:
                result += "_"

        # Ensure it starts with a letter or underscore
        if result and result[0].isdigit():
            result = f"r_{result}"

        return result.lower() or "resource"
