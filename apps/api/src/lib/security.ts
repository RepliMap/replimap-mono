/**
 * Security Utilities - The Sovereign Guard
 *
 * Cryptographic and security-related utilities.
 * Every function here is designed to be resistant to timing attacks and side-channels.
 */

import { AppError } from './errors';

// ============================================================================
// Constant-Time Comparison
// ============================================================================

/**
 * Compare two strings in constant time to prevent timing attacks.
 *
 * Timing attacks work by measuring how long a comparison takes.
 * If we use `===`, the comparison stops at the first mismatch,
 * leaking information about which characters are correct.
 *
 * This function always compares ALL characters, taking the same
 * time regardless of where mismatches occur.
 */
export function constantTimeEquals(a: string, b: string): boolean {
  // If lengths differ, we still need to do work to avoid timing leak
  // We use the longer string to ensure consistent timing
  const aLen = a.length;
  const bLen = b.length;

  // XOR of lengths will be 0 if equal
  let result = aLen ^ bLen;

  // Compare all characters of the longer string
  const maxLen = Math.max(aLen, bLen);
  for (let i = 0; i < maxLen; i++) {
    // Use modulo to safely access characters (wraps around for shorter string)
    const aChar = a.charCodeAt(i % aLen) || 0;
    const bChar = b.charCodeAt(i % bLen) || 0;
    result |= aChar ^ bChar;
  }

  return result === 0;
}

// ============================================================================
// Admin API Key Verification
// ============================================================================

/**
 * Verify admin API key from X-API-Key header.
 * Uses constant-time comparison to prevent timing attacks.
 *
 * @throws AppError if key is missing, invalid, or API is not configured
 */
export function verifyAdminApiKey(request: Request, adminKey: string | undefined): void {
  if (!adminKey) {
    throw new AppError(
      'INTERNAL_ERROR',
      'Admin API is not configured. Set ADMIN_API_KEY secret.',
      503
    );
  }

  const providedKey = request.headers.get('X-API-Key');

  if (!providedKey) {
    throw new AppError(
      'UNAUTHORIZED',
      'Missing X-API-Key header',
      401
    );
  }

  if (!constantTimeEquals(providedKey, adminKey)) {
    throw new AppError('UNAUTHORIZED', 'Invalid API key', 403);
  }
}

// ============================================================================
// HMAC Utilities for Machine Signature Verification
// ============================================================================

/**
 * Compute HMAC-SHA256 signature of a message.
 *
 * Used to verify that machine_id was generated by a legitimate CLI
 * and hasn't been tampered with.
 */
export async function computeHmacSignature(
  message: string,
  secretKey: string
): Promise<string> {
  const encoder = new TextEncoder();

  // Import the secret key
  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secretKey),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  );

  // Sign the message
  const signature = await crypto.subtle.sign(
    'HMAC',
    key,
    encoder.encode(message)
  );

  // Convert to hex string
  return Array.from(new Uint8Array(signature))
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Verify an HMAC signature against a message.
 * Uses constant-time comparison to prevent timing attacks.
 */
export async function verifyHmacSignature(
  message: string,
  signature: string,
  secretKey: string
): Promise<boolean> {
  const expectedSignature = await computeHmacSignature(message, secretKey);
  return constantTimeEquals(signature, expectedSignature);
}

// ============================================================================
// Request Validation Helpers
// ============================================================================

/**
 * Maximum allowed Content-Length for JSON requests (100KB).
 * This prevents DoS attacks via large payloads.
 */
export const MAX_CONTENT_LENGTH = 100 * 1024; // 100KB

/**
 * Validate request Content-Length to prevent DoS via large payloads.
 *
 * @throws AppError if Content-Length exceeds maximum
 */
export function validateContentLength(request: Request, maxBytes: number = MAX_CONTENT_LENGTH): void {
  const contentLength = request.headers.get('Content-Length');

  if (contentLength) {
    const length = parseInt(contentLength, 10);
    if (isNaN(length) || length > maxBytes) {
      throw new AppError(
        'INVALID_REQUEST',
        `Request body too large. Maximum: ${Math.round(maxBytes / 1024)}KB`,
        413
      );
    }
  }
}

/**
 * Validate request timestamp for replay attack protection.
 * Rejects requests that are too old or too far in the future.
 *
 * @param timestamp - Request timestamp in milliseconds since epoch
 * @param maxAgeMs - Maximum age of request in milliseconds (default: 5 minutes)
 * @param maxFutureMs - Maximum amount request can be in the future (default: 1 minute)
 */
export function validateRequestTimestamp(
  timestamp: number | undefined,
  maxAgeMs: number = 5 * 60 * 1000,
  maxFutureMs: number = 60 * 1000
): boolean {
  if (!timestamp) {
    // Timestamp is optional for backward compatibility
    return true;
  }

  const now = Date.now();
  const minTime = now - maxAgeMs;
  const maxTime = now + maxFutureMs;

  return timestamp >= minTime && timestamp <= maxTime;
}

// ============================================================================
// CLI Version Checking
// ============================================================================

/** Minimum supported CLI version */
const MIN_SUPPORTED_VERSION = '0.1.0';

/** Versions that should show deprecation warning */
const DEPRECATED_VERSIONS = ['0.9.0', '0.9.1', '0.9.2', '0.1.0', '0.1.1', '0.1.2'];

/** Version warning to include in response */
export interface VersionWarning {
  message: string;
  upgrade_command: string;
  severity: 'warning' | 'deprecated' | 'unsupported';
}

/**
 * Parse semver version string into comparable number.
 * Example: "1.2.3" -> 10203
 */
function parseVersion(version: string): number | null {
  const match = version.match(/^(\d+)\.(\d+)\.(\d+)/);
  if (!match) return null;

  const [, major, minor, patch] = match;
  return parseInt(major) * 10000 + parseInt(minor) * 100 + parseInt(patch);
}

/**
 * Check CLI version and return warning if outdated.
 * Does NOT reject requests - only warns for backward compatibility.
 */
export function checkVersionHeader(version: string | null): VersionWarning | null {
  if (!version) {
    // No version header - old CLI, warn but allow
    return {
      message: 'No CLI version header detected. Consider upgrading for best experience.',
      upgrade_command: 'pip install --upgrade replimap',
      severity: 'warning',
    };
  }

  const versionNum = parseVersion(version);
  const minVersionNum = parseVersion(MIN_SUPPORTED_VERSION);

  if (versionNum === null || minVersionNum === null) {
    return null; // Can't parse, allow
  }

  // Check if deprecated version
  if (DEPRECATED_VERSIONS.includes(version)) {
    return {
      message: `CLI version ${version} is deprecated. Please upgrade for security fixes and new features.`,
      upgrade_command: 'pip install --upgrade replimap',
      severity: 'deprecated',
    };
  }

  // Check if below minimum
  if (versionNum < minVersionNum) {
    return {
      message: `CLI version ${version} is outdated. Minimum supported: ${MIN_SUPPORTED_VERSION}`,
      upgrade_command: 'pip install --upgrade replimap',
      severity: 'unsupported',
    };
  }

  return null;
}

// ============================================================================
// CI/CD Environment Detection
// ============================================================================

/**
 * Detect if a machine ID indicates a CI/CD environment.
 * CI environments get special handling - ephemeral machine IDs with higher limits.
 */
export function isCIEnvironment(machineId: string, isCIFlag?: boolean): boolean {
  // Explicit flag from CLI takes precedence
  if (isCIFlag === true) return true;

  // Detect based on machine_id naming patterns
  const ciPatterns = [
    /^ci-/i,
    /^github-/i,
    /^gitlab-/i,
    /^jenkins-/i,
    /^circleci-/i,
    /^travis-/i,
    /^buildkite-/i,
    /^azure-pipelines-/i,
    /-ci-/i,
    /-runner-/i,
    /-agent-/i,
  ];

  return ciPatterns.some((pattern) => pattern.test(machineId));
}

/**
 * CI device limits per plan (more generous than regular devices)
 */
export const CI_DEVICE_LIMITS: Record<string, number> = {
  free: 3,
  solo: 10,
  pro: 25,
  team: 50,
  enterprise: -1, // Unlimited
};

// ============================================================================
// Abuse Detection
// ============================================================================

/**
 * Maximum number of ACTIVE devices (last 7 days) before flagging as potential abuse.
 * This is a soft limit - we warn but don't hard-block until extreme cases.
 *
 * IMPORTANT: We check ACTIVE devices, not lifetime total.
 * A user upgrading laptops over 5 years shouldn't be flagged.
 */
export const MAX_ACTIVE_DEVICES_BEFORE_WARNING = 10;
export const MAX_ACTIVE_DEVICES_BEFORE_ABUSE = 15;
export const MAX_NEW_DEVICES_PER_DAY = 5;

/**
 * Abuse detection result
 */
export interface AbuseCheckResult {
  isAbuse: boolean;
  warning: string | null;
  reason?: string;
}

/**
 * Check for device abuse based on ACTIVE devices (last 7 days).
 *
 * @param activeDeviceCount - Number of non-CI devices active in last 7 days
 * @param newDevicesToday - Number of new non-CI devices registered today
 */
export function checkDeviceAbuse(
  activeDeviceCount: number,
  newDevicesToday: number = 0
): AbuseCheckResult {
  // Rapid churn = key being passed around
  if (newDevicesToday >= MAX_NEW_DEVICES_PER_DAY) {
    return {
      isAbuse: true,
      warning: 'Too many new devices in short period.',
      reason: `${newDevicesToday} new devices in 24h indicates sharing`,
    };
  }

  // Too many active devices = sharing
  if (activeDeviceCount >= MAX_ACTIVE_DEVICES_BEFORE_ABUSE) {
    return {
      isAbuse: true,
      warning: `License used on ${activeDeviceCount} active devices. This appears to be shared.`,
      reason: `${activeDeviceCount} active devices in 7 days`,
    };
  }

  // Warning threshold
  if (activeDeviceCount >= MAX_ACTIVE_DEVICES_BEFORE_WARNING) {
    return {
      isAbuse: false,
      warning: `License used on ${activeDeviceCount} active devices. Consider upgrading to a team plan.`,
    };
  }

  return { isAbuse: false, warning: null };
}

/**
 * Legacy function for backward compatibility - checks total device count
 * @deprecated Use checkDeviceAbuse with active device count instead
 */
export function checkDeviceAbuseTotal(
  totalDeviceCount: number
): { isAbuse: boolean; warning: string | null } {
  // Higher thresholds for total count (lifetime)
  if (totalDeviceCount >= 50) {
    return {
      isAbuse: true,
      warning: `License used on ${totalDeviceCount} devices total. Contact support.`,
    };
  }

  if (totalDeviceCount >= 25) {
    return {
      isAbuse: false,
      warning: `License used on ${totalDeviceCount} devices. Consider upgrading to a team plan.`,
    };
  }

  return { isAbuse: false, warning: null };
}

// ============================================================================
// Error Sanitization (Hide Stack Traces)
// ============================================================================

/**
 * Sanitize error for external response.
 * Never expose stack traces or internal details to clients.
 */
export function sanitizeError(error: unknown, requestId?: string): {
  error: string;
  message: string;
  request_id?: string;
} {
  // Generate request ID if not provided
  const id = requestId || `REQ-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`.toUpperCase();

  // Log full error internally
  console.error(`[ERROR ${id}]`, error);

  // Return sanitized response
  return {
    error: 'INTERNAL_ERROR',
    message: 'An unexpected error occurred. Please try again.',
    request_id: id,
  };
}

/**
 * Log error with context for debugging, without exposing details.
 */
export function logError(context: string, error: unknown): void {
  const errorInfo = error instanceof Error
    ? { message: error.message, stack: error.stack, name: error.name }
    : { value: String(error) };

  console.error(`[ERROR] ${context}:`, JSON.stringify(errorInfo));
}

// ============================================================================
// Offline Lease Token (JWT)
// ============================================================================

/**
 * Lease token payload for offline validation.
 * CLI can cache this and verify locally when backend is unreachable.
 */
export interface LeasePayload {
  // License key (truncated for security)
  key: string;
  // Plan type
  plan: string;
  // Machine ID this lease is valid for
  mid: string;
  // Issued at (Unix timestamp)
  iat: number;
  // Expiration (Unix timestamp)
  exp: number;
}

/**
 * Default lease duration: 3 days (in seconds)
 */
export const LEASE_DURATION_SECONDS = 3 * 24 * 60 * 60;

/**
 * Create a signed lease token (JWT) for offline validation.
 *
 * Format: header.payload.signature (base64url encoded)
 * Algorithm: HS256 (HMAC-SHA256)
 */
export async function createLeaseToken(
  payload: Omit<LeasePayload, 'iat' | 'exp'>,
  secret: string,
  durationSeconds: number = LEASE_DURATION_SECONDS
): Promise<string> {
  const now = Math.floor(Date.now() / 1000);

  const fullPayload: LeasePayload = {
    ...payload,
    iat: now,
    exp: now + durationSeconds,
  };

  // Header (always HS256)
  const header = { alg: 'HS256', typ: 'JWT' };

  // Encode header and payload
  const encodedHeader = base64urlEncode(JSON.stringify(header));
  const encodedPayload = base64urlEncode(JSON.stringify(fullPayload));

  // Create signature
  const signatureInput = `${encodedHeader}.${encodedPayload}`;
  const signature = await hmacSign(signatureInput, secret);
  const encodedSignature = base64urlEncode(signature);

  return `${encodedHeader}.${encodedPayload}.${encodedSignature}`;
}

/**
 * Verify a lease token and return the payload if valid.
 * Returns null if invalid or expired.
 */
export async function verifyLeaseToken(
  token: string,
  secret: string
): Promise<LeasePayload | null> {
  try {
    const parts = token.split('.');
    if (parts.length !== 3) return null;

    const [encodedHeader, encodedPayload, encodedSignature] = parts;

    // Verify signature
    const signatureInput = `${encodedHeader}.${encodedPayload}`;
    const expectedSignature = await hmacSign(signatureInput, secret);
    const expectedEncodedSignature = base64urlEncode(expectedSignature);

    if (!constantTimeEquals(encodedSignature, expectedEncodedSignature)) {
      return null;
    }

    // Decode and parse payload
    const payload: LeasePayload = JSON.parse(base64urlDecode(encodedPayload));

    // Check expiration
    const now = Math.floor(Date.now() / 1000);
    if (payload.exp < now) {
      return null;
    }

    return payload;
  } catch {
    return null;
  }
}

// ============================================================================
// JWT Helper Functions
// ============================================================================

/**
 * Base64URL encode a string (for JWT)
 */
function base64urlEncode(str: string): string {
  const bytes = new TextEncoder().encode(str);
  let binary = '';
  for (const byte of bytes) {
    binary += String.fromCharCode(byte);
  }
  return btoa(binary)
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}

/**
 * Base64URL decode a string (for JWT)
 */
function base64urlDecode(str: string): string {
  // Add padding if needed
  let padded = str.replace(/-/g, '+').replace(/_/g, '/');
  while (padded.length % 4) {
    padded += '=';
  }

  const binary = atob(padded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return new TextDecoder().decode(bytes);
}

/**
 * HMAC-SHA256 sign a message, returning raw bytes as string
 */
async function hmacSign(message: string, secret: string): Promise<string> {
  const encoder = new TextEncoder();

  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  );

  const signature = await crypto.subtle.sign(
    'HMAC',
    key,
    encoder.encode(message)
  );

  // Convert to string of bytes
  const bytes = new Uint8Array(signature);
  let result = '';
  for (const byte of bytes) {
    result += String.fromCharCode(byte);
  }
  return result;
}
