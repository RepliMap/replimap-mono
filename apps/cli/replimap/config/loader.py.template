"""
RepliMap Configuration Loader

4-layer configuration loading system:
1. ENV - Environment variables (highest priority)
2. Drop-in - User config files (~/.config/replimap/)
3. Cache - Cached remote config
4. Bundled - Default bundled config (lowest priority)

Usage:
    from replimap.config.loader import ConfigLoader

    loader = ConfigLoader()
    config = await loader.load()

    # Access plan config
    plan = config.plans["pro"]
    print(f"Pro plan: ${plan.price_monthly / 100}/month")
"""

from __future__ import annotations

import asyncio
import hashlib
import json
import os
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from pathlib import Path
from typing import Any, Generic, Optional, TypeVar

import aiohttp

# Import bundled config (generated from packages/config)
from . import bundled_config


class ConfigSource(Enum):
    """Configuration source priority levels."""
    ENV = "env"
    DROP_IN = "drop_in"
    CACHE = "cache"
    BUNDLED = "bundled"


@dataclass
class ConfigMetadata:
    """Metadata about loaded configuration."""
    source: ConfigSource
    version: str
    loaded_at: datetime
    path: Optional[Path] = None

    def __str__(self) -> str:
        if self.path:
            return f"{self.source.value}:{self.path}"
        return f"{self.source.value}:v{self.version}"


T = TypeVar("T")


@dataclass
class ConfigValue(Generic[T]):
    """A configuration value with its source metadata."""
    value: T
    metadata: ConfigMetadata


@dataclass
class LoadedConfig:
    """Complete loaded configuration."""
    plans: dict[str, bundled_config.PlanConfig]
    frameworks: dict[str, bundled_config.FrameworkConfig]
    resources: dict[str, list[str]]
    version: str
    sources: list[ConfigMetadata] = field(default_factory=list)

    @property
    def primary_source(self) -> ConfigSource:
        """Return the highest priority source used."""
        if self.sources:
            return self.sources[0].source
        return ConfigSource.BUNDLED


class ConfigLoader:
    """
    4-layer configuration loader.

    Priority (highest to lowest):
    1. ENV - Environment variables starting with REPLIMAP_
    2. Drop-in - User config files in ~/.config/replimap/
    3. Cache - Cached remote configuration
    4. Bundled - Default bundled configuration
    """

    DEFAULT_CONFIG_DIR = Path.home() / ".config" / "replimap"
    DEFAULT_CACHE_DIR = Path.home() / ".cache" / "replimap"
    REMOTE_CONFIG_URL = "https://api.replimap.com/config/latest"
    CACHE_TTL = timedelta(hours=24)

    def __init__(
        self,
        config_dir: Optional[Path] = None,
        cache_dir: Optional[Path] = None,
        remote_url: Optional[str] = None,
    ):
        self.config_dir = config_dir or self.DEFAULT_CONFIG_DIR
        self.cache_dir = cache_dir or self.DEFAULT_CACHE_DIR
        self.remote_url = remote_url or self.REMOTE_CONFIG_URL
        self._session: Optional[aiohttp.ClientSession] = None

    async def load(self, sync_remote: bool = False) -> LoadedConfig:
        """
        Load configuration from all sources.

        Args:
            sync_remote: If True, fetch remote config before loading

        Returns:
            LoadedConfig with merged configuration
        """
        sources: list[ConfigMetadata] = []

        # Start with bundled config as base
        plans = dict(bundled_config.PLANS)
        frameworks = dict(bundled_config.COMPLIANCE_FRAMEWORKS)
        resources = dict(bundled_config.AWS_RESOURCES)
        version = bundled_config.CONFIG_VERSION

        sources.append(ConfigMetadata(
            source=ConfigSource.BUNDLED,
            version=version,
            loaded_at=datetime.now(),
        ))

        # Layer 3: Try to load from cache
        cached = await self._load_from_cache()
        if cached:
            self._merge_config(plans, frameworks, resources, cached["data"])
            version = cached["version"]
            sources.insert(0, ConfigMetadata(
                source=ConfigSource.CACHE,
                version=version,
                loaded_at=datetime.now(),
                path=self.cache_dir / "config.json",
            ))

        # Layer 2: Load drop-in configs
        drop_in = self._load_drop_in_configs()
        for config_path, config_data in drop_in:
            self._merge_config(plans, frameworks, resources, config_data)
            sources.insert(0, ConfigMetadata(
                source=ConfigSource.DROP_IN,
                version=self._compute_hash(config_data),
                loaded_at=datetime.now(),
                path=config_path,
            ))

        # Layer 1: Environment variable overrides
        env_overrides = self._load_env_overrides()
        if env_overrides:
            self._merge_config(plans, frameworks, resources, env_overrides)
            sources.insert(0, ConfigMetadata(
                source=ConfigSource.ENV,
                version=self._compute_hash(env_overrides),
                loaded_at=datetime.now(),
            ))

        # Optional: Sync from remote
        if sync_remote:
            asyncio.create_task(self._sync_remote_config())

        return LoadedConfig(
            plans=plans,
            frameworks=frameworks,
            resources=resources,
            version=version,
            sources=sources,
        )

    def _load_env_overrides(self) -> dict[str, Any]:
        """Load configuration from environment variables."""
        overrides: dict[str, Any] = {}

        # Example: REPLIMAP_PLANS_FREE_SCANS_PER_MONTH=20
        prefix = "REPLIMAP_"
        for key, value in os.environ.items():
            if not key.startswith(prefix):
                continue

            parts = key[len(prefix):].lower().split("_")
            if len(parts) < 2:
                continue

            # Build nested dict path
            current = overrides
            for part in parts[:-1]:
                if part not in current:
                    current[part] = {}
                current = current[part]

            # Parse value (try JSON, then int, then string)
            try:
                current[parts[-1]] = json.loads(value)
            except json.JSONDecodeError:
                try:
                    current[parts[-1]] = int(value)
                except ValueError:
                    current[parts[-1]] = value

        return overrides

    def _load_drop_in_configs(self) -> list[tuple[Path, dict[str, Any]]]:
        """Load configuration from drop-in directory."""
        configs: list[tuple[Path, dict[str, Any]]] = []

        if not self.config_dir.exists():
            return configs

        # Load *.json files in sorted order
        for config_file in sorted(self.config_dir.glob("*.json")):
            try:
                with open(config_file) as f:
                    config_data = json.load(f)
                configs.append((config_file, config_data))
            except (json.JSONDecodeError, IOError) as e:
                # Log warning but continue
                print(f"Warning: Failed to load {config_file}: {e}")

        return configs

    async def _load_from_cache(self) -> Optional[dict[str, Any]]:
        """Load cached configuration if valid."""
        cache_file = self.cache_dir / "config.json"

        if not cache_file.exists():
            return None

        try:
            with open(cache_file) as f:
                cached = json.load(f)

            # Check TTL
            cached_at = datetime.fromisoformat(cached.get("cached_at", ""))
            if datetime.now() - cached_at > self.CACHE_TTL:
                return None

            return cached
        except (json.JSONDecodeError, IOError, ValueError):
            return None

    async def _sync_remote_config(self) -> None:
        """Fetch and cache remote configuration."""
        try:
            if self._session is None:
                self._session = aiohttp.ClientSession()

            async with self._session.get(self.remote_url) as response:
                if response.status != 200:
                    return

                remote_config = await response.json()

                # Save to cache
                self.cache_dir.mkdir(parents=True, exist_ok=True)
                cache_file = self.cache_dir / "config.json"

                cache_data = {
                    "cached_at": datetime.now().isoformat(),
                    "version": remote_config.get("version", "unknown"),
                    "data": remote_config,
                }

                with open(cache_file, "w") as f:
                    json.dump(cache_data, f, indent=2)

        except Exception as e:
            # Log warning but don't fail
            print(f"Warning: Failed to sync remote config: {e}")

    def _merge_config(
        self,
        plans: dict[str, Any],
        frameworks: dict[str, Any],
        resources: dict[str, Any],
        override: dict[str, Any],
    ) -> None:
        """Merge override config into base configs."""
        if "plans" in override:
            for plan_name, plan_data in override["plans"].items():
                if plan_name in plans:
                    # Update existing plan
                    plans[plan_name] = bundled_config.PlanConfig(
                        price_monthly=plan_data.get("price_monthly", plans[plan_name].price_monthly),
                        scans_per_month=plan_data.get("scans_per_month", plans[plan_name].scans_per_month),
                        max_accounts=plan_data.get("max_accounts", plans[plan_name].max_accounts),
                        features=plan_data.get("features", plans[plan_name].features),
                        addons=plan_data.get("addons", plans[plan_name].addons),
                    )

        if "compliance_frameworks" in override:
            for fw_id, fw_data in override["compliance_frameworks"].items():
                if fw_id in frameworks:
                    frameworks[fw_id] = bundled_config.FrameworkConfig(
                        name=fw_data.get("name", frameworks[fw_id].name),
                        region=fw_data.get("region", frameworks[fw_id].region),
                        description=fw_data.get("description", frameworks[fw_id].description),
                        controls_count=fw_data.get("controls_count", frameworks[fw_id].controls_count),
                    )

        if "aws_resources" in override:
            for category, resource_list in override["aws_resources"].items():
                resources[category] = resource_list

    @staticmethod
    def _compute_hash(data: dict[str, Any]) -> str:
        """Compute a short hash for config data."""
        content = json.dumps(data, sort_keys=True)
        return hashlib.sha256(content.encode()).hexdigest()[:12]

    async def close(self) -> None:
        """Close any open connections."""
        if self._session:
            await self._session.close()
            self._session = None


# Convenience function for synchronous usage
def load_config_sync(**kwargs) -> LoadedConfig:
    """Synchronous wrapper for ConfigLoader.load()."""
    loader = ConfigLoader(**kwargs)
    return asyncio.run(loader.load())
